/*
 * Copyright (C) 2024 Abdalla Bushnaq
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.bushnaq.abdalla.engine;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
import com.badlogic.gdx.graphics.*;
import com.badlogic.gdx.graphics.Cubemap.CubemapSide;
import com.badlogic.gdx.graphics.Pixmap.Format;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.graphics.glutils.FrameBufferCubemap;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.ScreenUtils;
import net.mgsx.gltf.scene3d.utils.EnvironmentUtil;
import net.mgsx.gltf.scene3d.utils.FacedMultiCubemapData;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.Deflater;

/**
 * Quick procedural IBL environment generation.
 * Should be disposed when no longer used.
 * <p>
 * IBL generated by this class are accurate, some fast approximation are performed to provide
 * a quick way to setup an IBL environment. For accurate IBL, see:
 * https://learnopengl.com/PBR/IBL/Specular-IBL
 * and
 * https://learnopengl.com/PBR/IBL/Diffuse-irradiance
 * and related tools to generate them from HDRIs.
 *
 * @author mgsx
 */
public class myIBLBuilder implements Disposable {
    private static final Matrix4       matrix          = new Matrix4();
    public final         Color         farGroundColor  = new Color();
    public final         Color         farSkyColor     = new Color();
    public final         Array<Light>  lights          = new Array<Light>();
    public final         Color         nearGroundColor = new Color();
    public final         Color         nearSkyColor    = new Color();
    private final        Logger        logger          = LoggerFactory.getLogger(this.getClass());
    private final        String        outputDirectory;
    private final        ShaderProgram sunShader;
    public               boolean       renderGradient  = true;
    public               boolean       renderSun       = true;
    String              folder;
    File                folderFile;
    Map<String, String> sideNameMap = new HashMap<>();
    private ShapeRenderer shapes;
    private ShapeRenderer sunShapes;

    public myIBLBuilder(String outputDirectory) {
        this.outputDirectory = outputDirectory;
        shapes               = new ShapeRenderer(20);
        shapes.getProjectionMatrix().setToOrtho2D(0, 0, 1, 1);

        sunShader = new ShaderProgram(
                Gdx.files.classpath("net/mgsx/gltf/shaders/ibl-sun.vs.glsl"),
                Gdx.files.classpath("net/mgsx/gltf/shaders/ibl-sun.fs.glsl"));
        if (!sunShader.isCompiled()) throw new GdxRuntimeException(sunShader.getLog());

        sunShapes = new ShapeRenderer(20, sunShader);
        sunShapes.getProjectionMatrix().setToOrtho2D(0, 0, 1, 1);
        sideNameMap.put("PositiveX", "posx");
        sideNameMap.put("NegativeX", "negx");
        sideNameMap.put("PositiveY", "posy");
        sideNameMap.put("NegativeY", "negy");
        sideNameMap.put("PositiveZ", "posz");
        sideNameMap.put("NegativeZ", "negz");
    }

    private static void renderName(int size, CustomizedSpriteBatch batch, BitmapFont font, CubemapSide side) {
        batch.setProjectionMatrix(new OrthographicCamera(size, size).combined);
        batch.begin();
        final GlyphLayout layout = new GlyphLayout();
        String            text   = side.name();
        layout.setText(font, text);
        font.setColor(Color.WHITE);
        font.draw(batch, text, -layout.width / 2, -layout.height / 2);
        batch.end();
    }

    /**
     * Create an environment map, to be used with {@link net.mgsx.gltf.scene3d.scene.SceneSkybox}
     *
     * @param size  base size (width and height) for generated cubemap
     * @param batch
     * @param font
     * @return generated cubemap, caller is responsible to dispose it when no longer used.
     */
    public Cubemap buildEnvMap(int size, CustomizedSpriteBatch batch, BitmapFont font) {
        folder     = outputDirectory + "environment/";
        folderFile = new File(folder);
        if (folderFile.exists()) {
            logger.info("Loading IBL env map.");
            Cubemap map = EnvironmentUtil.createCubemap(new InternalFileHandleResolver(), folder + "/environment_", "_0.png", EnvironmentUtil.FACE_NAMES_NEG_POS);
            return map;
        } else {
            logger.info("Generating IBL env map.");
            FrameBufferCubemap fbo = new FrameBufferCubemap(Format.RGBA8888, size, size, false) {
                @Override
                protected void disposeColorTexture(Cubemap colorTexture) {
                }
            };
            fbo.begin();
            while (fbo.nextSide()) {
                Gdx.gl.glClearColor(0, 0, 0, 0);
                Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
                CubemapSide side = fbo.getSide();
                renderGradient(side, 0);
                renderLights(side, false);
//                renderName(size, batch, font, side);
                String fileName = String.format(folder + "environment_%s_0.png", sideNameMap.get(side.name()));
                PixmapIO.writePNG(Gdx.files.local(fileName), ScreenUtils.getFrameBufferPixmap(0, 0, size, size), Deflater.DEFAULT_COMPRESSION, false);
            }
            fbo.end();

            Cubemap map = fbo.getColorBufferTexture();
            fbo.dispose();
            return map;
        }
    }

    /**
     * Creates an irradiance map, to be used with {@link net.mgsx.gltf.scene3d.attributes.PBRCubemapAttribute#DiffuseEnv}
     *
     * @param size  base size (width and height) for generated cubemap
     * @param batch
     * @param font
     * @return generated cubemap, caller is responsible to dispose it when no longer used.
     */
    public Cubemap buildIrradianceMap(int size, CustomizedSpriteBatch batch, BitmapFont font) {
        folder     = outputDirectory + "irradiance/";
        folderFile = new File(folder);
        if (folderFile.exists()) {
            logger.info("Loading IBL irradiance map.");
            Cubemap map = EnvironmentUtil.createCubemap(new InternalFileHandleResolver(), folder + "/irradiance_", "_0.png", EnvironmentUtil.FACE_NAMES_NEG_POS);
            return map;
        } else {
            logger.info("Generating IBL irradiance map.");
            FrameBufferCubemap fbo = new FrameBufferCubemap(Format.RGBA8888, size, size, false) {
                @Override
                protected void disposeColorTexture(Cubemap colorTexture) {
                }
            };
            fbo.begin();
            while (fbo.nextSide()) {
                Gdx.gl.glClearColor(0, 0, 0, 0);
                Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
                CubemapSide side = fbo.getSide();
                renderGradient(side, 0.5f);
                renderLights(side, false);
//                renderName(size, batch, font, side);
                String fileName = String.format(folder + "irradiance_%s_0.png", sideNameMap.get(side.name()));
                PixmapIO.writePNG(Gdx.files.local(fileName), ScreenUtils.getFrameBufferPixmap(0, 0, size, size), Deflater.DEFAULT_COMPRESSION, false);
            }
            fbo.end();
            Cubemap map = fbo.getColorBufferTexture();
            fbo.dispose();
            return map;
        }
    }

    /**
     * Creates an radiance map, to be used with {@link net.mgsx.gltf.scene3d.attributes.PBRCubemapAttribute#SpecularEnv}
     * generated cubemap contains mipmaps in order to perform roughness in PBR shading
     *
     * @param mipMapLevels how many mipmaps level, eg. 10 levels produce a 1024x1024 cubemap with mipmaps.
     * @param batch
     * @param font
     * @return generated cubemap, caller is responsible to dispose it when no longer used.
     */
    public Cubemap buildRadianceMap(final int mipMapLevels, CustomizedSpriteBatch batch, BitmapFont font) {
        folder     = outputDirectory + "radiance/";
        folderFile = new File(folder);
        if (folderFile.exists()) {
            logger.info("Loading IBL radiance map.");
            Cubemap map = EnvironmentUtil.createCubemap(new InternalFileHandleResolver(), folder + "/radiance_", "_", "." + "png", mipMapLevels, EnvironmentUtil.FACE_NAMES_NEG_POS);
            return map;
        } else {
            logger.info("Generating IBL radiance map.");
            Pixmap[] maps  = new Pixmap[mipMapLevels * 6];
            int      index = 0;
            for (int level = 0; level < mipMapLevels; level++) {
                int         size = 1 << (mipMapLevels - level - 1);
                FrameBuffer fbo  = new FrameBuffer(Format.RGBA8888, size, size, false);
                fbo.begin();
                for (int s = 0; s < 6; s++) {
                    Gdx.gl.glClearColor(0, 0, 0, 0);
                    Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
                    CubemapSide side = CubemapSide.values()[s];
                    float       blur = (float) level / (float) mipMapLevels;
                    renderGradient(side, blur);
                    renderLights(side, false);
                    maps[index] = ScreenUtils.getFrameBufferPixmap(0, 0, size, size);
//                    renderName(size, batch, font, side);
                    String fileName = String.format(folder + "radiance_%s_%d.png", sideNameMap.get(side.name()), level);
                    PixmapIO.writePNG(Gdx.files.local(fileName), maps[index], Deflater.DEFAULT_COMPRESSION, false);

                    index++;
                }
                fbo.end();
                fbo.dispose();
            }
            FacedMultiCubemapData data = new FacedMultiCubemapData(maps, mipMapLevels);
            Cubemap               map  = new Cubemap(data);
            map.setFilter(TextureFilter.MipMap, TextureFilter.Linear);
            return map;
        }
    }

    @Override
    public void dispose() {
        sunShader.dispose();
        sunShapes.dispose();
        shapes.dispose();
    }

    private void renderGradient(Cubemap.CubemapSide side, float blur) {
        if (this.renderGradient) {
            Color aveSky     = this.farSkyColor.cpy().lerp(this.nearSkyColor, 0.5F);
            Color aveGnd     = this.farGroundColor.cpy().lerp(this.nearGroundColor, 0.5F);
            Color ave        = aveSky.cpy().lerp(aveGnd, 0.5F);
            Color aveHorizon = this.farGroundColor.cpy().lerp(this.farSkyColor, 0.5F);
            float t2         = 1.0F - (float) Math.pow((double) (1.0F - blur), 4.0);
            float t          = 1.0F - (float) Math.pow((double) (1.0F - blur), 1.0);
            Color ngc        = this.nearGroundColor.cpy().lerp(ave, t);
            Color nsc        = this.nearSkyColor.cpy().lerp(ave, t);
            Color fgc        = this.farGroundColor.cpy().lerp(aveHorizon, t2).lerp(ave, t);
            Color fsc        = this.farSkyColor.cpy().lerp(aveHorizon, t2).lerp(ave, t);
            this.shapes.begin(ShapeType.Filled);
            if (side == CubemapSide.PositiveY) {
                this.shapes.rect(0.0F, 0.0F, 1.0F, 1.0F, nsc, nsc, nsc, nsc);
            } else if (side == CubemapSide.NegativeY) {
                this.shapes.rect(0.0F, 0.0F, 1.0F, 1.0F, ngc, ngc, ngc, ngc);
            } else {
                this.shapes.rect(0.0F, 0.0F, 1.0F, 0.5F, nsc, nsc, fsc, fsc);
                this.shapes.rect(0.0F, 0.5F, 1.0F, 0.5F, fgc, fgc, ngc, ngc);
            }

            this.shapes.end();
        }
    }

    private void renderLights(CubemapSide side, boolean blured) {

        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE);

        for (Light light : lights) {
            if (blured) {
                light.render(side, sunShapes, sunShader, .5f, 1f);
            } else {
                light.render(side, sunShapes, sunShader, 1f);
            }
        }

        Gdx.gl.glDisable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);
    }

    public static class Light {

        private static final Vector3 localDir    = new Vector3();
        private static final Vector3 localSunDir = new Vector3();
        private static final Vector3 localUp     = new Vector3();
        private static final Matrix4 matrix      = new Matrix4();
        public final         Color   color       = new Color(1f, 1f, 1f, 1f);
        public final         Vector3 direction   = new Vector3(0, -1, 0);
        public               float   exponent    = 30f;

        private void render(CubemapSide side, ShapeRenderer shapes, ShaderProgram shader, float strength) {
            render(side, shapes, shader, strength, exponent);
        }

        private void render(CubemapSide side, ShapeRenderer shapes, ShaderProgram shader, float strength, float exponent) {
            shader.bind();
            shader.setUniformf("u_exponent", exponent);
            shader.setUniformf("u_ambient", color.r, color.g, color.b, 0f);
            shader.setUniformf("u_diffuse", color.r, color.g, color.b, strength);

            localDir.set(side.direction);
            localUp.set(side.up);

            // XXX patch
            if (side == CubemapSide.NegativeX || side == CubemapSide.PositiveX) {
                localDir.x = -localDir.x;
            }

            matrix.setToLookAt(localDir, localUp).tra();
            localSunDir.set(direction).scl(-1, -1, 1).mul(matrix); // XXX patch again

            shader.setUniformf("u_direction", localSunDir);

            shapes.begin(ShapeType.Filled);
            shapes.rect(0, 0, 1, 1);
            shapes.end();
        }
    }

}
